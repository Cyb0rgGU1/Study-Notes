**Kubernetes** is a popular open source platform for managing containerized workloads; provides a framework that enables you to build an _individual_ platform for your workload. 

## Monolithic vs Microservices: Pros and Cons

Legacy applications are usually designed with a **monolithic** approaches in mind:
- self contained
- single code base
- single binary file that can run on a server. 

> Monoliths are difficult to manage due to the complexity, scale development, implement changes fast, and fails with scaling the application out. 

**Cloud native architecture's** basic idea is to _break down applications to smaller pieces, making them more manageable._

> _Microservices_ are multiple decoupled applications that communicate with each other in a network that provide functionality. 

**Microservices** make it possible to have multiple teams, each holding ownership of different funtions of your application, but also gives the _ability to scale them out individually_. 


## Characteristics of Cloud Native Arch
- High level of automation
    - CI/CD pipelines
- Self healing
    - monitor the applicatio from the inside and automatically restart
- Scalable
    - handling more load
- Cost-Efficient
    - k8 help with more efficient and denser placing of applications
- Easy to maintain
    - using _microservices_
- Secure by default
    - requiring authentication from every user and process

### **Autoscaling**
- pattern that describes the dynamic adjustment of resources based on the current demand
-  CPU and memory are the obvious metrics to decide on 
- other methods based on time or business metrics can also be considered 

### *I. Horizontal*
- When talking about *autoscaling*, talking about _horizontal scaling_ which is the process of spawning new computer resources. 
- Can be new copies of your application process, virtual machines, new racks of servers and/or other hardware. 

### *II. _Vertical_*
- describes the change in size of the underlying hardware
- scaling up by allowing them to consume more CPU and memory
- a limit is defined by the compute and memory capacity of the underlying hardware

### *III. Example*
- Vertical scaling
    - If you pick up a heavy object, you build muscle to carry it yourself but your upper body has a limit of strength
- Horizontal scaling
    - if you call your friends to help and share the work

> The ability to scale your application can increase availability and resilence of your services in more traditional enviornments. 

## Serverless 
- Servers are still required as the basis of the application. 
    - configure several resources
        - network, vms, os, and load balancers
- serverless computing as an even stronger focus on the on-demand provisioning and scaling applications. 
- **Autoscaling is an important core concept of servless**
    - helps with precise billing
- **FaaS**
    - vendors have offerings of properetary serverless runtimes and subsets
    - provide the underlying INF so devs can deploy software
    - often used in combination or as an extension of existing platforms 
    - allow for fast deployment and excellent testing/sandbox env
    - struggles with standardization 
### Open standards
- Cloud native technologies rely heavily on open source software
- Everyone can collaborate
- Easy to implement indutry-wide standards
- _containers_ evolved as a standardized way to package and ship modern software

~**STANDARDS WHICH DEFINE THE WAY HOW TO BUILD AND RUN CONTAINERS**~
| image-spec | runtime-spec | distribution-spec |
|----| ---- | ---- |
|defines how to build and package container images| specifies the configuration, execution environment and lifecycle of containers| provides a standard for the distrbution of content in general and container images in particular|  

|OCI Spec| CNI | CRI | CSI | SMI |
| ---- | ---- | ---- | ---- | ---- |
| - | Container network interface | Container runtime interface | Container storage interface | Service Mesh Interface | 
| image, runtime and distribution specification on how to run and build a container | how to implement networking for Containers | how to implement container runtimes in orchestration systems | implement storage in container orchestration systems | implement Service Meshs in container systems **with a focus on K8**
